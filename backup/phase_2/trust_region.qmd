---
title: "Rapport de projet - phase 2 - Région de confiance"
subtitle: "MTH8408"
author:
  - name: Oihan Cordelier, Oussama Mouhtal
    email: oihan.cordelier@polymtl.ca, oussama-2.mouhtal@polymtl.ca
    affiliation:
      - name: Polytechnique Montréal
format:
  pdf:
    keep-tex: false
    documentclass: article
    include-in-header:
      - text: |
            \usepackage{xspace}
    geometry:
      - margin=1in
    papersize: letter
    colorlinks: true
    urlcolor: blue
engine: julia
---


## Lien GitHub
Ce projet est accessible sur le dépot GitHub au lien suivant : [https://github.com/oihanc/mth8408_projet](https://github.com/oihanc/mth8408_projet).




## L-BFGS


# Région de confiance

L'utilisation de CG et de L-BFGS est pour résoudre le sous-problème de minimisation du modèle quadratique. Nous nous sommes donc aussi intéressés à l'implémentation de l'algorithme de région de confiance. 
Pour le moment, nous avons reproduit l'algorithme tel que fournie dans le cahier du GERAD (Bourhis et al., 2019), cependant le code reste fortement inspiré du code `trunk` du module `JSOSolver.jl`. Un possible objectif pour la troisième phase de ce projet serait de directement modifier le solveur `trunk`. À des fins de comparaison, nous avons appelé notre solveur `TRSolver`. Afin de valider notre implémentation, nous l'avons comparé avec le solveur `trunk`ainsi que `Ipopt`. Notre solveur permet d'utiliser comme sous-solveur CG ou bien L-BFGS. Pour ce dernier, il est possible de varier le paramètre de mémoire. 


Pour la deuxième phase, nous avons eu comme objectifs de :


- Valider l'implémentation de `TRSolver` avec CG (notre implémentation) contre le solveur `trunk`. Ce sont essentiellement les mêmes algorithmes. Puisque `trunk` est déjà fortement optimisé, si `TRSolver` obtient des performances similaires, cela veut dire que notre implémentation de l'algorithme de région de confiance est efficace. 
- Comparer les performances de `TRSolver` avec CG et avec L-BFGS. L'idée est d'identifier si, à ce stade, nous avons des gains en efficacité avec L-BFGS. 
- Comparer les performances de `TRSolver` avec L-BFGS pour différents paramètres de mémoire. L'objectif est d'identifier comment le paramètre de mémoire impacte l'efficacité de l'algorithme.



Le code ci-dessous est celui de l'algorithme de région de confiance. Comme mentionné plus tôt, il est fortement inspiré de celui provenant de `JSOSolver`. Notamment, un effort particulier a été apporté pour le rendre compatible avec le module `SolverCore` et `SolverTools`. L'implémentation se base sur celle du cahier du GERAD (Bourhis et al., 2019). Une différence notable est la modification dynamique de la tolérance relative du sous-solveur. Celle-ci suit l'implémentation dans `JSOSolver` afin de s'assurer qu'elle ne soit jamais plus stricte que le solveur de région de confiance.


Voici les modifications les plus importantes par rapport à la phase 1 : 


- Compatibilité avec les modules `SolverTools` et `SolverBenchmark` pour faciliter les comparaisons. On peut noter particulièrement l'utilisation de la structure `GenericExecutionStats`, l'ajout du temps écoulé et du statut de convergence.
- Utilisation de l'opérateur hessien du NLPModel au lieu de la matrice hessienne pour gagner en efficacité. 
- Le réglage dynamique de la tolérance relative du sous-solveur.


{{< pagebreak >}}


```julia
{{< include TRSolver.jl >}}
```


Pour comparer les performances des solveurs, nous utilisons tous les problèmes non contraints de dimensions 100 dans le module `OptimizationProblems`. Les profiles de performance sont faits avec le module `OptimizationBenchmark`. Ceci permet d'illustrer la portion de problème résolu par les algorithmes en fonction d'un ratio d'itération ou de temps. 


Un problème est dit $\tau$-résolu si la condition suivante est rencontrée : 


\begin{align*}
\frac{f^i - f^0}{f^* - f^0} \geq (1 - \tau)
\end{align*}


Les algorithmes suivants sont testés :


- `trunk` : région de confiance avec CG (implémentation provenant de `JSOSolver`)
- `trSolver_cg` : région de confiance avec CG 
- `trsolver_lbfgs` : région de confiance avec L_BFGS. Le nombre associé indique la mémoire utilisée.
- `Ipopt` : optimiseur à points intérieurs


Le script ci-dessous permet de lancer les différents solveurs sur les problèmes tests. Les données sont sauvegardées et peuvent être réutilisées plus tard sans relancer les tests.


{{< pagebreak >}}


```julia
{{< include benchmark_solvers.jl >}}
```


Nous proposons 3 profiles de performance en fonction de plusieurs critères, soit le nombre d'itérations, le nombre d'évaluations de la fonction objective et le temps écoulé. Nous proposons ces 3 critères puisque certains algorithmes peuvent prendre moins d'itérations que d'autres, cependant chaque itération est plus longue à évaluer. 


![Profile de performance en fonction du nombre d'itérations](performance_profile_iter.png){width=80%  fig-align="center"}


![Profile de performance en fonction du nombre d'évaluations de la fonction objective](performance_profile_neval.png){width=80% fig-align="center"}


![Profile de performance en fonction du temps écoulé](performance_profile_time.png){width=80% fig-align="center"}



### Classement des algorithmes
À la lumière des résultats obtenus, nous pouvons déjà tirer quelques conclusions sur notre implémentation de l'algorithme de région de confiance. Le profile de performance en fonction du temps illustre que : 


- `trunk` est l'implémentation qui résout le plus de problèmes rapidement. 
- `TRSolver` performe initialement moins bien, mais rapidement rapidement `trunk`. 
- `TRSolver` avec L-BFGS performe nettement moins bien. 
- `Ipopt` est l'algorithme le moins efficace en termes de temps.


### Influence des paramètres de L-BFGS


![Profile de performance en fonction du temps écoulé pour les sous-solveurs L-BFGS](performance_profile_time_lbfgs.png){width=80% fig-align="center"}


Le profile de performance ci-haut montre qu'il y a peu de gain en efficacité lorsque la mémoire est augmentée. Cependant, on peut tout de même noter que lorsque la mémoire est réglée à 10 et sans mise à l'échelle, l'optimiseur de région de confiance performe légèrement mieux qu'avec les autres paramètres de mémoire. Il reste donc à voir si avec une implémentation plus efficace de L-BFGS, nous pouvons obtenir de meilleur résultat que `TRSolver` avec CG. De plus, il serait intéressant de voir s'il est possible d'aller chercher des gains supplémentaires en augmentant davantage la mémoire.


## Difficultés rencontrées


- Pour l'implémentation du sous-solveur L-BFGS, nous voulions initialement modifier le code de `trunk`. À la place nous avons jugé qu'il était plus facile de reproduit l'algorithme de région de confiance pour faire des tests initiaux avec L-BFGS. Son utilisation reste compatible avec `SolverCore`.



## Résumé de ce qui a été accompli
- Comparaison de la résolution des sous-problèmes convexes avec CG, L-BFGS et DIOM.
- Implémentation de l'algorithme de région de confiance revue
- Comparaison des divers solveurs avec `SolverBenchmark`
- Comparaison de l'effet de la mémoire et de la mise à l'échelle avec le sous-solveur L-BFGS.



## Étapes à terminer
- L'implémentation de L-BFGS doit absolument être revue. Elle est loin d'être assez efficace pour être sérieusement comparé avec CG.
- Ajouter DIOM comme sous-solveur possible dans l'algorithme de région de confiance `TRSolver`.
- Comparer les solveurs sur des problèmes de plus grandes dimensions (au minimum 1000 variables).
- *Si les prochains résultats avec L-BFGS sont concluants, il serait intéressant de modifier la fonction `trunk` pour permettre l'utilisation de L-BFGS*.



## Annexes


Code L-BFGS avec région de confiance(non optimisé, implémentation à revoir)
```julia
{{< include subsolvers.jl >}}
```