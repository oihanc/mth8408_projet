---
title: "Rapport de projet - phase 1"
subtitle: "MTH8408"
author:
  - name: Oihan Cordelier, Oussama Mouhtal
    email: oihan.cordelier@polymtl.ca, oussama-2.mouhtal@polymtl.ca
    affiliation:
      - name: Polytechnique Montréal
format:
  pdf:
    keep-tex: false
    documentclass: article
    include-in-header:
      - text: |
            \usepackage{xspace}
    geometry:
      - margin=1in
    papersize: letter
    colorlinks: true
    urlcolor: blue
engine: julia
---


```{julia}
#| echo: false
#| output: false
using Pkg
Pkg.activate("projet_env_phase2")
Pkg.add("ADNLPModels")
Pkg.add("NLPModels")
Pkg.add("Krylov")
Pkg.add("LinearOperators")
Pkg.add("JSOSolvers")
Pkg.add("Plots")

Pkg.add("OptimizationProblems")  # collection + outils pour sélectionner les problèmes
include("subsolvers.jl")
# TODO: add CUTest
Pkg.add("SuiteSparseMatrixCollection")
Pkg.add("MatrixMarket")
using LinearAlgebra, NLPModels , ADNLPModels, Printf, Krylov, LinearOperators, SuiteSparseMatrixCollection, MatrixMarket 

using OptimizationProblems, OptimizationProblems.ADNLPProblems, JSOSolvers

using Plots
# gr(fmt = :png)
```


## Lien GitHub
Ce projet est accessible sur le dépot GitHub au lien suivant : [https://github.com/oihanc/mth8408_projet](https://github.com/oihanc/mth8408_projet).

# Contenu
Ce rapport est divisé en deux parties :

- Une première partie consacrée à la comparaison des performances de \texttt{LBFGS} (pour différentes tailles de mémoire) avec celles de \texttt{CG} et \texttt{DIOM}.\
- Une seconde partie portant sur la résolution de problèmes non linéaires.

# Résolution de quadratique convexe

Cette partie consiste à comparer \texttt{CG} et \texttt{DIOM} à \texttt{LBFGS}. Le tableau ci-dessous récapitule l’ensemble des matrices SDP utilisées dans cette section.

\begin{center}
\begin{tabular}{lrrrr}
\toprule
Nom & n  & Condition number κ₂ \\
\midrule
494\_bus & 494 & 2.415×10\(^{6}\) \\
1138\_bus & 1 138 & 8.572×10\(^{6}\) \\
662\_bus & 662 &  7.941×10\(^{5}\) \\
bcsstk06 & 420 & 7.570×10\(^{6}\) \\
\bottomrule
\end{tabular}
\end{center}


```{julia}
"""
      get_mm()
Charge une matrice depuis la SuiteSparse Matrix Collection
"""
function get_mm(matrix_name)
  ssmc = ssmc_db()
  pb = ssmc_matrices(ssmc, "", matrix_name)
  fetch_ssmc(pb, format="MM")
  pb_path = fetch_ssmc(pb, format="MM")
  path_mtx = pb_path[1]
  A = MatrixMarket.mmread(joinpath(path_mtx, matrix_name * ".mtx"))
  #b = MatrixMarket.mmread(joinpath(path_mtx, matrix_name * "_b.mtx"))
  return A
end

"""
      memory(n, p)
Génère des indices équidistants pour mémoire limitée
"""
function memory(n, p)
    @assert 1 ≤ p ≤ n "p doit être entre 1 et n"
    indices = [floor(Int, i*n/p) for i in 1:p]
    indices = unique(sort(indices))  
    return indices
end

"""
      cg_lbfgs(A, b, name, listmem, atol, rtol)
Compare CG et L-BFGS pour différentes tailles de mémoire, et sauvegarde un graphique
"""
function cg_lbfgs(A, b, name, listmem, atol, rtol)
  

  (xcg,statscg) = cg(A, b; atol=atol, rtol=rtol,history=true)
  (xlbfgs,statslbfgs) = lbfgs(A, b; atol=atol, rtol=rtol, mem = 1) 
  gr()
  plot(statscg.residuals, label="‖r‖ cg ", lw=1, yaxis=:log, linestyle = :dot, xlabel="Itération", legend = :bottomleft)
  plot!(statslbfgs.residuals, label="‖r‖ lbfgs $(m = 1)", lw=1, linestyle = :dash)

  for mem in listmem
    (xlbfgs,statslbfgs) = lbfgs(A, b; atol=atol, rtol=rtol, mem = mem)  
    p = round(Int64, 100 * mem / n)
    if p > 0 && p < 100
      plot!(statslbfgs.residuals, label="‖r‖ lbfgs $(m = p)%", lw=1,linestyle = :dash)
    else
      plot!(statslbfgs.residuals, label="‖r‖ lbfgs $(m = p)%", lw=1,linestyle = :dot)
    end
    
  end
    
  savefig("CG_versus_lbfgs_$(name).pdf")
end

"""
    diom_lbfgs(A, b, name, listmem, atol, rtol)
Compare DIOM et L-BFGS pour différentes tailles de mémoire, et sauvegarde un graphique
"""
function diom_lbfgs(A, b, name, listmem, atol, rtol)
  
  (xlbfgs,statslbfgs) = lbfgs(A, b; atol=atol, rtol=rtol, mem = 2)  
  (xdiom,statsdiom) = diom(A, b; memory =2, atol=atol, rtol=rtol,history=true)
  gr()
  plot(statslbfgs.residuals, label="‖r‖ lbfgs $(m = 2)", lw=1,yaxis=:log, linestyle = :dash, xlabel="Itération",legend = :bottomright)
  plot!(statsdiom.residuals, label="‖r‖ diom $(m = 2)", linestyle = :dot, lw=1)
  for mem in listmem
    p = round(Int64, 100 * mem / n)
    if mem > 2 && p > 0
    (xlbfgs,statslbfgs) = lbfgs(A, b; atol=atol, rtol=rtol, mem = mem)  
    (xdiom,statsdiom) = diom(A, b; memory = mem,atol=atol, rtol=rtol,history=true)
    plot!(statslbfgs.residuals, label="‖r‖ lbfgs $(m = p)%", linestyle = :dash,lw=1)
    plot!(statsdiom.residuals, label="‖r‖ diom $(m = p)%", linestyle = :dot,lw=1)
    end
  end
  savefig("Diom_versus_lbfgs_$(name).pdf")
end

"""
      orthogonality_loss(A, b; maxiter, mem)
Calcule la perte d’orthogonalité associée aux directions L-BFGS pour plusieurs itérations

## Les tolérances dans lbfs sont ceux par défaut atol=1e-18, rtol=1e-18
"""

function orthogonality_loss(A, b; maxiter=10, mem=1)
    Loss = Float64[]
    for i in 2:maxiter
        (xlbfgs,statslbfgs) =  lbfgs(A, b; mem=mem, itmax = i)
        U = tril(statslbfgs.PAP, -1)                        # partie triangulaire inférieure stricte
        I_U = I + U         # U + I
        loss = norm(U)        # || (U + I)^(-1) * U ||_2
        push!(Loss, loss)              
    end        
    return Loss
end
```

## Comparaison CG à LBFGS

Dans cette partie, nous comparons la méthode du gradient conjugué (\texttt{CG}) à \texttt{LBFGS}, en faisant varier la taille de la mémoire utilisée. Nous traçons la norme du résidu en fonction des itérations. Voici les remarques principales :\

- \texttt{CG} génère des résidus très similaires à ceux de \texttt{LBFGS} avec une mémoire de taille 1. Dans les deux cas, la convergence n’est pas atteinte en $n$ itérations, en raison de la perte d’orthogonalité.\

- En augmentant la taille de la mémoire, la convergence de \texttt{LBFGS} s’améliore. Avec la mémoire complète, la solution est retrouvée en $n$ itérations (étant donné que \texttt{atol = rtol =} $10^{-9}$). Cependant, on observe que lorsque la norme du résidu devient très faible, \texttt{LBFGS} peine à continuer la réduction du résidu.

- La matrice utiliser est `494_bus`.

```{julia}
A = get_mm("494_bus")
n,n = size(A)
b = randn(eltype(A), n)
atol = 1e-9
rtol = 1e-9
p=4
listmem = memory(n, p)
cg_lbfgs(A, b, "494_bus", listmem,atol, rtol)
```

![](CG_versus_lbfgs_494_bus.pdf);

## Perte de conjugaison dans les directions de LBFGS

- Dans cette partie on vise à analyser la perte de conjugaison des directions générées. Soit $P_k \in \mathbb{R}^{n \times k}$ la matrice contenant les $k$ premières directions normalisées $d_i$. Si la famille $\{d_i\}$ est une base $A$-conjuguée, alors on devrait avoir :
$$
P_k^\top A P_k = I.
$$
Comme cette matrice est symétrique, on peut la décomposer en une somme :
$$
P_k^\top A P_k = U_k^\top + D_k + U_k.
$$
Une façon de mesurer la perte de conjugaison consiste donc à évaluer la norme de $U_k$, qui devrait être nulle si la conjugaison est parfaite. La figure ci dessous illustre l'volution de la norme de $U_k$ au cours des itérations pour différentes valeur du mémoire. La mtrice utiliser dans cette partie est `bcsstk06`.

- Il est important de souligner qu’une amélioration significative de la perte de conjugaison est obtenue  on augementant la mémoire de la matrice `lbfgs`. Meme on peut remarquer que dès une itération supérieur à la taille de la mémoire on perte la propriété de conjugaison des directions (ce n'est pas une généralisation).

```{julia}
A = get_mm("bcsstk06")
n,n = size(A)
b = randn(eltype(A), n)
p=5
listmem = memory(n, p)
Loss = orthogonality_loss(A, b; maxiter = n)
plot(Loss, label="$(m = 1)", lw=2, yaxis=:log, linestyle = :dot, xlabel="Itération", legend = :topleft)
for mem in listmem
  Loss = orthogonality_loss(A, b; maxiter = n, mem=mem)
  p = round(Int64, 100 * mem / n)
  if p > 0
    plot!(Loss, label="$(m = p)%", linestyle = :dot, lw=2)
  end
end
savefig("Loss_conjugacy.pdf")
```

![](Loss_conjugacy.pdf);


## Comparaison DIOM à LBFGS

- Cette partie est dédiée à la comparaison entre \texttt{DIOM} et \texttt{LBFGS}. La méthode \texttt{DIOM} est implémentée de manière à conserver en mémoire les vecteurs de la base générée au cours du processus de Krylov. En arithmétique exacte, cet algorithme est équivalent à la méthode du gradient conjugué (\texttt{CG}) pour les matrices SDP. De plus, en pratique, \texttt{DIOM} se comporte comme \texttt{CG} avec réorthogonalisation.

- On remarque que \texttt{LBFGS} et \texttt{DIOM} génèrent des résidus presque identiques au début. Toutefois, à partir d’un certain nombre d’itérations --- lorsque la norme du résidu devient très faible --- \texttt{DIOM} surpasse \texttt{LBFGS}, ce dernier n’étant plus capable de faire progresser la réduction du résidu.


```{julia}
A = get_mm("494_bus")
n,n = size(A)
b = randn(eltype(A), n)
p=2
listmem = memory(n, p)
diom_lbfgs(A, b, "494_bus", listmem,atol, rtol)
```

![](Diom_versus_lbfgs_494_bus.pdf);



```{julia}
A = get_mm("1138_bus")
n,n = size(A)
b = randn(eltype(A), n)
p=2
listmem = memory(n, p)
diom_lbfgs(A, b, "1138_bus", listmem,atol, rtol)
```

![](Diom_versus_lbfgs_1138_bus.pdf);





```{julia}
A = get_mm("662_bus")
n,n = size(A)
b = randn(eltype(A), n)
p=2
listmem = memory(n, p)
diom_lbfgs(A, b, "662_bus", listmem, atol, rtol)
```

![](Diom_versus_lbfgs_662_bus.pdf);


## Prochain travaux

- Implémenter dans \texttt{Krylov.jl} une version de \texttt{DIOM} adaptée à la résolution de sous-problèmes de région de confiance.

- Analyser la stagnation de \texttt{LBFGS} lorsque la norme du résidu devient très faible (inférieure à $10^{-6}$).

- Finaliser une implémentation opérationnelle de la méthode \texttt{LBFGS}.
